# 核心概念与最终算法流程

本文档详细描述了基于超维计算（Hyperdimensional Computing）的癫痫检测算法的最终版核心概念、设计思路和完整流程。该算法支持**增量式学习**和**双模式操作**（连续长信号与离散数据片段）。

---

## 1. 特征提取: 局部二值模式 (LBP)
为了捕捉信号在微观时间尺度上的“形态”或“模式”，我们为每个时间点计算一个LBP码。

- **过程**: 对于每个通道的每个采样点 `x(t)`，我们观察其与后续 `k` 个采样点之间的关系来生成一个 `k` 位的二进制码（默认 `k=6`）。
- **比较规则**:
    - 如果 `x(t+i+1) > x(t+i)` (信号上升)，记为 `1`。
    - 如果 `x(t+i+1) <= x(t+i)` (信号下降或持平)，记为 `0`。
- **结果**: 这个过程在信号上逐点滑动，为每个通道的每个时间点都生成一个LBP码。

---

## 2. HDC基础构建模块
### 2.1. 项目记忆 (Item Memory - IM)
IM是一个预先生成、且在整个分析过程中保持不变的查找表，是我们进行编码的“字典”。

- **构成**:
    1.  **LBP模式向量**: 为每一种可能的LBP码（当k=6时，有 `2^6 = 64` 种）生成一个随机的、唯一的 `D` 维二进制向量（`D=10,000`）。
    2.  **通道向量**: 为每一个电极通道生成一个随机的、唯一的 `D` 维二进制向量。
- **特性**: IM中的所有基础向量在“维度的祝福”下都近似相互正交。

### 2.2. 绑定 (Binding - ⊕)
此操作用于唯一地表示 **“在哪个通道上出现了哪种LBP模式”**。它是通过 **逐位异或 (XOR)** 实现的。

### 2.3. 捆绑 (Bundling)
此操作用于将多个向量聚合为一个代表性的向量。它是通过 **逐位多数投票求和 (Majority-Vote Sum)** 实现的。在当前实现中，如果出现平局（即输入向量数量为偶数时），平局的位将通过随机选择（0或1）来决定，以确保结果的无偏性。

---

## 3. 编码过程: 从信号到H向量
针对一个短时间窗口（例如 `w=1.0` 秒），我们通过以下两步将其编码为一个单一的 `D` 维超向量 `H`。

### 3.1. 空间捆绑 (Spatial Bundling)
在同一个时刻 `t`，对所有通道的 **(LBP向量 ⊕ 通道向量)** 进行 **捆绑** 操作，生成一个代表该时刻 **全脑空间信息** 的向量 `S`。

### 3.2. 时间捆绑 (Temporal Bundling)
在一个时间窗口内（例如1.0秒），我们会得到一系列的 `S` 向量。将这个窗口内所有的 `S` 向量再次进行 **捆绑** 操作，得到最终的 **窗口特征向量 `H`**。

---

## 4. 训练流程
模型支持增量式学习，可以处理任意数量的训练样本。

### 4.1. 增量式原型更新
- **输入**: 一个训练数据片段 `data_clip` 及其标签 (`'ictal'` 或 `'interictal'`)。
- **过程**:
    1.  为该片段计算出其 `H` 向量集合。
    2.  如果对应的原型（`Ictal_Prototype` 或 `Interictal_Prototype`）已存在，则将新计算出的 `H` 向量们与现有原型进行 **捆绑**，从而更新原型。
    3.  如果原型不存在，则直接用新计算出的 `H` 向量们 **捆绑** 生成初始原型。
- **调用**: 用户可以多次调用 `train(data_clip, label, sf)` 方法，逐步优化原型。

### 4.2. 自动化置信度阈值计算
- **目的**: 数据驱动地设定后处理所需的置信度阈值 `tr`。
- **时机**: 在所有发作期（Ictal）训练片段都提供完毕后，调用一次 `calculate_tr_threshold()` 方法。
- **过程**:
    1.  方法会遍历所有提供过的发作期训练片段。
    2.  为每个片段的每个子窗口计算其 **置信度分数**（见下一节）。
    3.  收集所有这些置信度分数。
    4.  将 `tr_threshold` 设置为这些分数的一个较低的百分位数（例如第20百分位数），这个百分比是可控的。

---

## 5. 推断流程
系统支持对连续信号和离散片段两种模式的推断。

### 5.1. 核心分类与置信度
- **过程**: 对于每一个分析窗口，计算出其 `H_query` 向量。
- **决策**:
    1.  计算 `H_query` 与两个原型向量的汉明距离 `dist_to_ictal` 和 `dist_to_interictal`。
    2.  标签由距离更近的原型决定。
    3.  同时计算 **置信度分数**: `confidence = abs(dist_to_ictal - dist_to_interictal)`。
- **输出**: 一个 `(标签, 置信度)` 元组的列表。

### 5.2. 两种推断模式
- **连续信号模式 `classify()`**: 输入一个长信号，通过滑动窗口（例如，窗口1.0秒，步长0.5秒）进行分析，返回覆盖整个信号的结果列表。
- **离散片段模式 `classify_clip()`**: 输入一个数据片段，对其进行分析并返回该片段的结果列表。

---

## 6. 后处理流程
根据操作模式的不同，后处理分为两种。

### 6.1. 连续信号后处理
#### 6.1.1. 双阈值平滑
- **目的**: 将带有噪声的瞬时标签流平滑为稳定、可靠的初步事件。
- **过程**:
    1.  使用一个滑动窗口（例如5秒）观察分类结果流。
    2.  **时间一致性检查**: 统计窗口内 "Ictal" 标签的数量是否超过阈值 `tc_threshold` (例如7)。
    3.  **置信度检查**: 如果满足 `tc`，则计算这些 "Ictal" 标签的 **平均置信度** 是否超过自动计算的 `tr_threshold`。
    4.  只有同时满足两个条件，才将当前时刻的最终决策判为 “SEIZURE”。

#### 6.1.2. 事件聚合与边界扩展
- **目的**: 将平滑后的决策流转换为最终的事件列表。
- **过程**:
    1.  **聚合**: 遍历决策流，找出所有 "SEIZURE" 状态的开始和结束时间点。
    2.  **边界扩展**: 对每个检测到的事件，应用**安全裕度**。
        -   开始时间点向前移动 `pre_margin_sec` (例如1秒)。
        -   结束时间点向后移动 `post_margin_sec` (例如5秒)。
    3.  **事件融合**: 检查扩展后的事件是否存在时间上的重叠，若有，则将它们合并为一个单一、连续的事件。

### 6.2. 离散片段后处理
- **目的**: 对单个数据片段给出一个最终的分类裁决。
- **过程**:
    1.  接收 `classify_clip()` 返回的结果列表。
    2.  对整个片段的所有结果执行与 **6.1.1** 类似的双阈值检查（检查 "Ictal" 总数是否超 `tc`，平均置信度是否超 `tr`）。
    3.  给出一个单一的最终裁决：“SEIZURE” 或 “NON-SEIZURE”。

---

## 7. 最终代码结构

```
seizure_detection/
├── seizure_detector/        # 核心Python包
│   ├── __init__.py          # 使目录成为一个包，并定义公共API
│   ├── data_handler.py      # 管理连续信号数据，提供片段提取功能
│   ├── lbp_feature_extractor.py # LBP特征提取
│   ├── hd_operations.py     # 核心HDC操作 (绑定, 捆绑)
│   ├── hd_encoder.py        # 将特征编码为H向量
│   ├── hdc_classifier.py    # 核心分类器，支持增量学习和双模式推断
│   ├── post_processor.py    # 后处理器，实现双阈值、边界扩展和融合
│   └── export.py            # 导出结果为MNE兼容的.fif文件
│
├── example_continuous.py    # 演示处理连续长信号的脚本
└── example_clips.py         # 演示处理离散数据片段的脚本
``` 